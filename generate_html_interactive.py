from main import *
from get_redundancy import find_redundancy
import os
import json

def generate_html_visualization():
    """
    Generate an interactive HTML file for redundancy pattern visualization.
    """
    ell = 12
    m = 12
    
    # Generate the matrices
    x = np.kron(s_matrix(ell), np.eye(m))
    y = np.kron(np.eye(ell), s_matrix(m))
    
    A = trimatrix_sum_mod2(matrix_power(x,3), y, matrix_power(y,2))
    B = trimatrix_sum_mod2(matrix_power(y,3), x, matrix_power(x,2))
    
    HX = glue_matrices(A, B)
    HZ = glue_matrices(matrix_transpose(B), matrix_transpose(A))
    
    # Analyze redundancies
    _, _, redundant_rows_HX, dependencies_HX = find_redundancy(HX)
    _, _, redundant_rows_HZ, dependencies_HZ = find_redundancy(HZ)
    
    # Prepare redundancy data
    redundancies = []
    
    # HX redundancies
    for i, redundant_row in enumerate(redundant_rows_HX, 1):
        dependencies = dependencies_HX[redundant_row]
        redundancy_set = sorted(dependencies + [redundant_row])
        redundancies.append({
            'id': f'HX{i}',
            'name': f'HX Matrix Row {redundant_row}',
            'redundant_row': redundant_row,
            'dependencies': dependencies,
            'redundancy_set': redundancy_set,
            'color': 'rgba(229, 117, 117, 0.8)'  # Red with transparency
        })
    
    # HZ redundancies
    for i, redundant_row in enumerate(redundant_rows_HZ, 1):
        dependencies = dependencies_HZ[redundant_row]
        redundancy_set = sorted(dependencies + [redundant_row])
        redundancies.append({
            'id': f'HZ{i}',
            'name': f'HZ Matrix Row {redundant_row}',
            'redundant_row': redundant_row,
            'dependencies': dependencies,
            'redundancy_set': redundancy_set,
            'color': 'rgba(0, 160, 135, 0.8)'  # Blue-green with transparency
        })
    
    # Generate HTML content
    html_content = f'''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Redundancy Pattern Visualization</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 20px;
        }}
        .container {{
            display: flex;
            gap: 20px;
        }}
        .grid-container {{
            position: relative;
        }}
        .grid {{
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat({ell}, 1fr);
            grid-template-rows: repeat({m}, 1fr);
            border: 2px solid #333;
            background-color: #808080;
        }}
        .cell {{
            border: 1px dashed #404040;
            position: relative;
            cursor: pointer;
        }}
        .controls {{
            min-width: 300px;
        }}
        .redundancy-item {{
            margin: 5px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: white;
            cursor: pointer;
            user-select: none;
        }}
        .redundancy-item:hover {{
            background-color: #f5f5f5;
        }}
        .redundancy-item.selected {{
            background-color: #e8f4f8;
            border-color: #007acc;
        }}
        .info-panel {{
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }}
        .clear-btn {{
            padding: 10px 20px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
        }}
        .clear-btn:hover {{
            background-color: #c82333;
        }}
    </style>
</head>
<body>
    <h1>Interactive Redundancy Pattern Visualization ({ell}Ã—{m} Grid)</h1>
    
    <div class="container">
        <div class="grid-container">
            <div class="grid" id="grid">
                <!-- Grid cells will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="controls">
            <h3>Redundancy Patterns</h3>
            <button class="clear-btn" onclick="clearSelection()">Clear All</button>
            <div id="redundancy-list">
                <!-- Redundancy items will be generated by JavaScript -->
            </div>
            
            <div class="info-panel">
                <h4>Selected Patterns:</h4>
                <div id="selected-info">None selected</div>
                <h4>XOR Result:</h4>
                <div id="xor-result">No overlapping cells</div>
            </div>
        </div>
    </div>

    <script>
        const ell = {ell};
        const m = {m};
        
        // Redundancy data
        const redundancies = {json.dumps(redundancies)};
        
        // Selected redundancy patterns
        let selectedPatterns = new Set();
        
        // Grid state: stores color information for each cell
        let gridState = {{}};
        
        // Initialize grid
        function initializeGrid() {{
            const grid = document.getElementById('grid');
            for (let row = 0; row < m; row++) {{
                for (let col = 0; col < ell; col++) {{
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${{row}}-${{col}}`;
                    cell.addEventListener('click', () => cellClicked(row, col));
                    grid.appendChild(cell);
                }}
            }}
        }}
        
        // Initialize redundancy list
        function initializeRedundancyList() {{
            const list = document.getElementById('redundancy-list');
            redundancies.forEach(redundancy => {{
                const item = document.createElement('div');
                item.className = 'redundancy-item';
                item.id = `item-${{redundancy.id}}`;
                item.innerHTML = `
                    <strong>${{redundancy.name}}</strong><br>
                    <small>Dependencies: ${{redundancy.dependencies.length}} rows</small><br>
                    <small>Total elements: ${{redundancy.redundancy_set.length}}</small>
                `;
                item.addEventListener('click', () => toggleRedundancy(redundancy.id));
                list.appendChild(item);
            }});
        }}
        
        // Toggle redundancy pattern selection
        function toggleRedundancy(id) {{
            const item = document.getElementById(`item-${{id}}`);
            
            if (selectedPatterns.has(id)) {{
                selectedPatterns.delete(id);
                item.classList.remove('selected');
            }} else {{
                selectedPatterns.add(id);
                item.classList.add('selected');
            }}
            
            updateVisualization();
            updateInfo();
        }}
        
        // Mix colors using XOR-like logic
        function mixColors(colorInfo) {{
            // XOR mod 2 logic: 
            // - Odd number of patterns: show color
            // - Even number of patterns: show no color (background)
            
            if (colorInfo.length % 2 === 1) {{
                // Odd number of patterns - show a representative color
                // For simplicity, show the first pattern's color
                // Or mix all colors if you want a blend
                return colorInfo[0].color;
            }} else {{
                // Even number of patterns (including 0) - XOR cancellation
                // Return transparent to show background
                return 'transparent';
            }}
        }}

        // Update grid visualization based on selected patterns
        function updateVisualization() {{
            // Reset grid state
            gridState = {{}};
            
            // Apply each selected pattern
            selectedPatterns.forEach(patternId => {{
                const redundancy = redundancies.find(r => r.id === patternId);
                if (redundancy) {{
                    redundancy.redundancy_set.forEach(element => {{
                        const col = Math.floor(element / m);
                        const row = element % m;
                        const cellKey = `${{row}}-${{col}}`;
                        
                        if (!gridState[cellKey]) {{
                            gridState[cellKey] = [];
                        }}
                        
                        // Add this pattern's color to the cell
                        gridState[cellKey].push({{
                            pattern: patternId,
                            color: redundancy.color,
                            isRedundant: element === redundancy.redundant_row
                        }});
                    }});
                }}
            }});
            
            // Update visual appearance of cells
            for (let row = 0; row < m; row++) {{
                for (let col = 0; col < ell; col++) {{
                    const cell = document.getElementById(`cell-${{row}}-${{col}}`);
                    const cellKey = `${{row}}-${{col}}`;
                    
                    if (gridState[cellKey] && gridState[cellKey].length > 0) {{
                        // Perform XOR-like color mixing
                        const finalColor = mixColors(gridState[cellKey]);
                        
                        // Only set background if there's a visible color
                        if (finalColor === 'transparent') {{
                            cell.style.backgroundColor = ''; // Show default gray background
                        }} else {{
                            cell.style.backgroundColor = finalColor;
                        }}
                        
                        // Add border for redundant rows
                        const hasRedundant = gridState[cellKey].some(c => c.isRedundant);
                        if (hasRedundant) {{
                            cell.style.border = '2px solid #000';
                        }} else {{
                            cell.style.border = '1px dashed #404040';
                        }}
                    }} else {{
                        // Reset to default
                        cell.style.backgroundColor = '';
                        cell.style.border = '1px dashed #404040';
                    }}
                }}
            }}
        }}
        
        // Handle cell clicks
        function cellClicked(row, col) {{
            const cellKey = `${{row}}-${{col}}`;
            const element = row + col * m;
            
            if (gridState[cellKey]) {{
                console.log(`Cell (${{row}}, ${{col}}) - Element ${{element}}:`);
                gridState[cellKey].forEach(info => {{
                console.log(`  Pattern: ${{info.pattern}}, Redundant: ${{info.isRedundant}}`);
            }});
        }}
    }}
    
    // Update info panel
    function updateInfo() {{
        const selectedInfo = document.getElementById('selected-info');
        const xorResult = document.getElementById('xor-result');
        
        if (selectedPatterns.size === 0) {{
            selectedInfo.innerHTML = 'None selected';
            xorResult.innerHTML = 'No overlapping cells';
            return;
        }}
        
        // Show selected patterns
        const selectedNames = Array.from(selectedPatterns).map(id => {{
            const redundancy = redundancies.find(r => r.id === id);
            return redundancy ? redundancy.name : id;
        }});
        selectedInfo.innerHTML = selectedNames.join('<br>');
        
        // Calculate XOR overlaps
        const overlaps = {{}};
        Object.keys(gridState).forEach(cellKey => {{
            if (gridState[cellKey].length > 1) {{
                const patterns = gridState[cellKey].map(c => c.pattern).sort().join('+');
                if (!overlaps[patterns]) {{
                    overlaps[patterns] = 0;
                }}
                overlaps[patterns]++;
            }}
        }});
        
        if (Object.keys(overlaps).length === 0) {{
            xorResult.innerHTML = 'No overlapping cells';
        }} else {{
            const overlapText = Object.entries(overlaps)
                .map(([patterns, count]) => `${{patterns}}: ${{count}} cells`)
                .join('<br>');
            xorResult.innerHTML = overlapText;
        }}
    }}
    
    // Clear all selections
    function clearSelection() {{
        selectedPatterns.clear();
        document.querySelectorAll('.redundancy-item').forEach(item => {{
            item.classList.remove('selected');
        }});
        updateVisualization();
        updateInfo();
    }}
    
    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', () => {{
        initializeGrid();
        initializeRedundancyList();
    }});
    </script>
</body>
</html>
'''
    
    # Save HTML file
    output_file = 'redundancy_interactive_visualization.html'
    with open(output_file, 'w') as f:
        f.write(html_content)
    
    print(f"Interactive HTML visualization saved as: {output_file}")
    print(f"Total redundancy patterns: {len(redundancies)}")
    print("Features:")
    print("- Click on redundancy patterns to toggle selection")
    print("- Multiple patterns overlay with XOR color mixing")
    print("- Clickable grid cells show detailed pattern information")
    print("- Gray background with dashed grid lines")
    print("- Bold borders highlight redundant rows")
    print(f"\nOpen '{output_file}' in your web browser to use the interactive visualization.")

if __name__ == "__main__":
    generate_html_visualization()